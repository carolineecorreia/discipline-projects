# -*- coding: utf-8 -*-
"""SistemasMassaMola.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hFhriv7RfrpsICOCVtfHvVEwhC43kQig

# **Vamos analisar o sistema massa-mola a partir do método de Euler e explorar os detalhes da implementação**



# TRANSLATION
# ** Let's look at the spring mass system using the Euler method and explore the implementation details **



# **1. Método de Euler**
"""

from numpy import * 
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import *

x = 1 #condição inicial
v = 0 #condição inicial

dt = 0.1 #passo de tempo que queremos
t = 0 #tempo inicial

posicao = []
tempo = []

for i in range(0,500): #quantidade de iterações
  v = v - dt*x
  x = x + dt*v 
  t = t + dt
  posicao.append(x)
  tempo.append(t)

plt.plot(tempo, posicao, 'o', color='k')
plt.ylabel('x(t)')
plt.xlabel('tempo')
plt.grid(False)
plt.title("Aplicação do método de Euler num sistema massa mola")

#savefig("figura1.png", dpi=300, bbox_inches='tight')

"""Note, contudo, que o que implementamos, na verdade, foi essa equação aqui $x^{N+1}=x^N+v^{N+1}\Delta t$, em vez de $x^{N+1}=x^N+v^{N}\Delta t$ (no código, atualizamos a velocidade antes da posição e utilizamos o valor da velocidade da iteração atual para determinar a posição).


Vamos adotar uma abordagem diferente e implementar as equações conforme o especificado. O código será muito parecido com o último:
"""

from numpy import * 
import numpy as np
from matplotlib.pyplot import *
import matplotlib.pyplot as plt

x = 1 #condição inicial
v = 0 #condição inicial

dt = 0.1 #passo de tempo que queremos
t = 0 #tempo inicial

posicao = []
tempo = []

v_anterior = v
for i in range(0,500): #quantidade de iterações 
  v = v - dt*x
  x = x + dt*v_anterior  

  v_anterior = v

  t = t + dt

  posicao.append(x)
  tempo.append(t)

plt.plot(tempo, posicao, 'o', color='k',
        markersize=3, linewidth = 3,
        markerfacecolor='white',
        markeredgecolor='black',
        markeredgewidth=3)
plt.ylabel('x(t)')
plt.xlabel('tempo')
plt.grid(False)
plt.title("Aplicação do método de Euler 'verdadeiro' num sistema massa mola")

#savefig("figura2.png", dpi=300, bbox_inches='tight')

"""Este é o gráfico que mostra que o método de Euler não é muito preciso, porque tem erro local proporcional a $\Delta t ^2$. Existem opções melhores, como o primeiro código que mostramos e outros métodos que podem ser verificados nas referências.

# **2. Erro local**

Vamos voltar à aproximação da série de Taylor e usá-la para estimar o erro na aproximação da derivada. 

A seguir, vamos exemplificar com um código que vai nos gerar um gráfico para vermos a solução com o "verdadeiro" Euler e a solução exata da equação diferencial $\frac{df}{dt}=f(t)$, que é $f(t) = \text{e}^t$

Dependendo do tamanho do passo de tempo, a integração do Euler pode ser estável ou instável. Conforme aumentamos o intervalo de tempo entre uma iteração e outra, começamos a notar as oscilações:
"""

import numpy as np
import matplotlib.pyplot as plt

steps = 20

def solucao_exata(t):
    return np.exp(t) #solução da equação diferencial que escolhemos

#Euler:
def solucao_numerica(y0, dt, num_steps):
    y = np.zeros(num_steps + 1)
    y[0] = y0
    for step in range(num_steps):
        y[step + 1] = y[step] + y[step] * dt

    return y

t0 = 0
time = np.linspace(t0, 0.5, steps+1) #início do intervalo, quantidade de divisões no intervalo, quantidade de iterações
num_sol = solucao_numerica(solucao_exata(t0), time[1]-time[0], steps) #delta t de cada iteração = time[1]-time[0]

exact_sol = solucao_exata(time)

print("delta t = %f" % (time[1]-time[0])) #dt = passo de tempo de cada iteração

fig = plt.figure()
plt.plot(time, num_sol, ".--", label="Numérica")
plt.plot(time, exact_sol, label="Exata")
plt.title("Comparação entre o método de Euler e a solução exata")
plt.legend()
plt.ylabel("Solução")
plt.xlabel("delta t")
plt.show()

#fig.savefig("figura4.png", dpi=300, bbox_inches='tight')

